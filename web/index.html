<!DOCTYPE html>
<html>

<head>

	<meta charset="UTF-8">
	<meta content="IE=Edge" http-equiv="X-UA-Compatible">
	<meta name="description" content="A new Flutter project.">

	<!-- iOS meta tags & icons -->
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<meta name="apple-mobile-web-app-title" content="medlike">
	<link rel="apple-touch-icon" href="icons/Icon-192.png">

	<!-- Favicon -->
	<link rel="icon" type="image/png" href="favicon.png" />

	<title>medlike</title>
	<link rel="manifest" href="manifest.json">
	<script src="./bundle.js"></script>
	<script>
		var bridge = window.webBridgeInstance;
		var debugCounter = 0;
		async function sendBotEvent(jsonEventObject, data) {
			let eventObject = JSON.parse(jsonEventObject);
			if (data) eventObject.params.body = data;
			console.log('sendBotEvent start', eventObject);
			return new Promise((resolve, reject) => {
				console.log('bridge.sendBotEvent(eventObject)', eventObject);
				var index = debugCounter;
				debugCounter++;
				console.log('bridge.sendBotEvent(index)', index);
				console.log('bridge.sendBotEvent(timestamp)', Date.now());
				bridge.sendBotEvent(eventObject)
					.then((res) => {
						console.log('bridge.sendBotEvent method success', res);
						try {
							console.log('bridge.sendBotEvent success:', res);
							console.log('bridge.sendBotEvent success(index)', index);
							console.log('bridge.sendBotEvent success(timestamp)', Date.now());
							resolve(JSON.stringify(res));
						} catch (err) {
							console.log('bridge.sendBotEvent error:', res);
							console.log('bridge.sendBotEvent error(index)', index);
							console.log('bridge.sendBotEvent error(timestamp)', Date.now());
							resolve(res);
						}

					})
					.catch((err) => {
						console.log('sending event object: ', eventObject);
						console.log('bridge.sendBotEvent error', err);
						console.log('bridge.sendBotEvent error(index)', index);
						console.log('bridge.sendBotEvent error(timestamp)', Date.now());
						reject(JSON.stringify(err))
					})
			});
		}

    async function sendClientEvent(jsonEventObject) {
			const eventObject = JSON.parse(jsonEventObject);
			console.log('sendClientEvent start', eventObject);
			return new Promise((resolve, reject) => {
				bridge.sendClientEvent(eventObject)
					.then((res) => {
						console.log('bridge.sendClientEvent success', res);
						try {
							resolve(JSON.stringify(res));
						} catch (err) {
							resolve(res);
						}

					})
					.catch((err) => {
						console.log('sending event object: ', eventObject);
						console.log('bridge.sendClientEvent error', err);
						reject(JSON.stringify(err))
					})
			});
		}

		bridge?.sendClientEvent({
			method: 'ready',
			params: {}
		});

		bridge?.disableRenameParams();
	</script>

	<div id="loading">
		<style>
			body {
				inset: 0;
				overflow: hidden;
				margin: 0;
				padding: 0;
				position: fixed;
				left: 0;
				top: 0;
				right: 0;
				bottom: 0;
			}
			#loading {
				width: 100%;
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			#loading img {
				width: 90px;
				height: 90px;
    		}
			#loading.main_done img {
				opacity: 1;
			}
			#loading.init_done img {
				opacity: 0.05;
			}
		</style>
		<img src="./icons/Icon-512-filled.png" alt="Loading..."/>
	</div>

	<script>
		function base64Encode(buf) {
			let string = '';
			(new Uint8Array(buf)).forEach(
				(byte) => { string += String.fromCharCode(byte) }
			)
			return btoa(string)
		}

		async function postData(url = '', data = {}, headers = {}, method = 'GET') {
			// Default options are marked with *
			let response;
			switch (true) {
				case method === 'GET':
					response = await fetch(url, {
						method: method, // GET
						cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
						credentials: 'same-origin', // include, *same-origin, omit
						headers: headers,
						redirect: 'follow', // manual, *follow, error
						referrerPolicy: 'no-referrer', // no-referrer, *client
					});
					return response.json();
					break;

				case method === 'GET_IMAGE':
					response = await fetch(url, {
						method: 'GET', // *GET_IMAGES
						cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
						credentials: 'same-origin', // include, *same-origin, omit
						headers: headers,
						redirect: 'follow', // manual, *follow, error
						referrerPolicy: 'no-referrer', // no-referrer, *client
					});
					let text = base64Encode(await response.arrayBuffer());
					return text;
					break;

				default:
					response = await fetch(url, {
						method: method, // POST, PUT, DELETE, etc.
						cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
						credentials: 'same-origin', // include, *same-origin, omit
						headers: headers,
						redirect: 'follow', // manual, *follow, error
						referrerPolicy: 'no-referrer', // no-referrer, *client
						body: JSON.stringify(data) // body data type must match "Content-Type" header
					});
					return await response.json();
					break;
			}
		}

		async function sendBotEvent(jsonEventObject, data) {
			// console.log('!!!!!!!!!!!!!!!, files', data);
			// console.log('@@@@@@', data instanceof FormData);
			// console.log('#####3', typeof data);
			// const eventObject = JSON.parse(jsonEventObject);
			let eventObject = JSON.parse(jsonEventObject);
			if (data) eventObject.params.body = data;
			console.log('sendBotEvent start', eventObject);
			return new Promise((resolve, reject) => {
			console.log('!!!!!!!!!!!!!!!!!!!!!!!!');
			console.log(eventObject);
				postData(eventObject.params.url, eventObject.params.body, eventObject.params.headers, eventObject.params.method)
					.then((res) => {
						switch (true) {
							case eventObject.params.method === 'GET_IMAGE':
								resolve(res);
								break;

							default:
								resolve(JSON.stringify({
									ref: '_',
									type: 'smartapp_rpc',
									files: [],
									payload: {
										status: 'ok',
										result: {
											status: 'success',
											statusCode: 200,
											content: res,
										}
									}
								}));
								break;
						}

					})
					.catch((err) => {
						console.log('Ошибка на этапо запроса к боту. Содержимое ошибки ниже')
						console.log(err);
						reject(JSON.stringify(err));
					})
			});
		}
	</script>  -->
	<script>
		window.flutterConfiguration = {
			canvasKitBaseUrl: "./canvaskit/"
		};
	</script>
	<!--    <script src="./flutter.js" defer></script>-->
</head>

<body>
	<!-- This script installs service_worker.js to provide PWA functionality to
     application. For more information, see:
     https://developers.google.com/web/fundamentals/primers/service-workers -->
	<script>
		var serviceWorkerVersion = null;
		var scriptLoaded = false;
		function loadMainDartJs() {
			if (scriptLoaded) {
				return;
			}
			scriptLoaded = true;
			var scriptTag = document.createElement('script');
			scriptTag.src = './main.dart.js';
			scriptTag.type = 'application/javascript';
			document.body.append(scriptTag);
			/*
			var loading = document.querySelector("#loading");
			loading.classList.add("main_done");
			window.setTimeout(function () {
				loading.remove();
			}, 200);
			*/
		}

		if ('serviceWorker' in navigator) {
			// Service workers are supported. Use them.
			window.addEventListener('load', function () {
				// Wait for registration to finish before dropping the <script> tag.
				// Otherwise, the browser will load the script multiple times,
				// potentially different versions.
				var serviceWorkerUrl = './flutter_service_worker.js?v=' + serviceWorkerVersion;
				navigator.serviceWorker.register(serviceWorkerUrl)
					.then((reg) => {
						function waitForActivation(serviceWorker) {
							serviceWorker.addEventListener('statechange', () => {
								if (serviceWorker.state == 'activated') {
									console.log('Installed new service worker.');
									loadMainDartJs();
								}
							});
						}
						if (!reg.active && (reg.installing || reg.waiting)) {
							// No active web worker and we have installed or are installing
							// one for the first time. Simply wait for it to activate.
							waitForActivation(reg.installing || reg.waiting);
						} else if (!reg.active.scriptURL.endsWith(serviceWorkerVersion)) {
							// When the app updates the serviceWorkerVersion changes, so we
							// need to ask the service worker to update.
							console.log('New service worker available.');
							reg.update();
							waitForActivation(reg.installing);
						} else {
							// Existing service worker is still good.
							console.log('Loading app from service worker.');
							loadMainDartJs();
						}
					});

				// If service worker doesn't succeed in a reasonable amount of time,
				// fallback to plaint <script> tag.
				setTimeout(() => {
					if (!scriptLoaded) {
						console.warn(
							'Failed to load app from service worker. Falling back to plain <script> tag.',
						);
						loadMainDartJs();
					}
				}, 4000);
			});
		} else {
			// Service workers not supported. Just drop the <script> tag.
			loadMainDartJs();
		}

	</script>
</body>

</html>